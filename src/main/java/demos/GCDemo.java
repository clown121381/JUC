package demos;

import java.util.Random;

/**
 *
 *  +++++++++++++++++++++++++++++++++++++++++++++++++++++垃圾回收器+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *  算法：
 *      引用计数法
 *      复制算法
 *      标记清楚
 *      标记整理
 *   ------------------------------
 *  垃圾回收的方式
 *   *  1、Serial：串行回收
 *   *  2、Parallel：并行回收
 *   *  3、CMS：并发标记清除
 *   *  4、G1：G1
 *  截止到java10之后有ZGC
 *  -------------------------------------------------------------------------------
 *  Seial：串行垃圾回收，单线程垃圾回收的时候会停掉用户的线程进行垃圾回收不适合服务器的环境
 *  Parallel：并行垃圾回收多个垃圾收集线程并行工作也会停掉垃圾回收的时候用户的线程
 *  CMS：用户线程和垃圾回收线程同时执行（不一定是并行，可以是交替执行）不需要暂停用户线程
 *  G1：将堆内存分割成为不同的区域然后对各个区域并发的进行垃圾回收
 *
 *
 *  =======================================================================================================================
 *  垃圾收集器（查看默认的垃圾收集器 java -XX:+PrintCommandLineFlags -----> -XX:+UseParallelGC）
 *  7种垃圾收集器(新生代的收集器和老年代的收集器可以互相的激活组合搭配使用及只配置一方就可以默认的选择使用另一方)
 *
 *            新生代
 *
 *  Serial收集器:简单高效的最古老的收集器
 *  -XX:+UseSerialGC   配置之后就会启用   新生代：Serial Copying  ------ 老年代：Serial CMS(Serial Old)     进行垃圾收集
 *  ----------------------------------------------------------------------------------------------------------------------------------------
 *  ParNew：并行收集器新生代的收集器在垃圾收集的时候也会暂停应用其实就是serial的并行版本      新生代的默认收集器
 *  -XX:+UserParNewGC 开启后使用  ParNew+Serial CMS(Serial Old)的组合(不推荐组合)   他只会影响新生代不会印象老年代新生代使用Parallel new 并行进行垃圾回收
 *  -----------------------------------------------------------------------------------------------------------------------------------------
 *  Parallel: 并行垃圾回收
 *  -XX:+UseParallelGC -XX:+UseParallelOldGC   开启后 新生代老年代都会采用并行垃圾回收     (jdk1.8)Parallel Scavenge + Parallel Compacting(Parallel Old)
 *  关注Parallel Scavenge可控的吞吐量，自适应的调节策略动态的调整参数提供最合适的停顿时间(jdk1.6之前之关注新生代的吞吐量使用Parallel Scavenge + Serial Old 的组合)
 *
 *  ==================================================================================================================================================
 *            老年代
 *
 *  Parallel Old：并行垃圾回收
 *  -XX:+UseParallelOldGC
 *  --------------------------------------------------------------------------------------------------------------------------------------------------
 *  CMS: 标记清除 算法的实现，是一种获取最短回收收集停顿时间的收集器，并发是指于用户线程一起执行
 *  -XX:+ConcMarkSweepGC 开启之后会自动激活 -XX:+UserParNewGC 使        CMS + Serial Old(后备收集器备用) + ParNew 一起配合的使用
 *  工作的四部
 *      1、初始标记：只是标记一下GC Roots能直接关联的对象，速度很快但仍需要暂停所有的工作线程
 *      2、并发标记：和用户线程一起工作进行GC Roots的跟踪过程，和用户线程一起工作不需要暂停，主要标记过程，标记全部对象
 *      3、重新标记：修正在并发标记期间，因用户线程继续运行，而导致标记产生变动的那一部分对象的标记记录，仍需要暂停所有工作的相乘
 *          由于并发标记时，用户线程依然运行，因此在正式清理前。在做修正。
 *      4、并发清除：和用户线程一起，清除GC Roots 不可达的对象，和用户线程一起工作，不需要暂停工作线程，基于标记的结构直接清理对象
 *          由于耗时最长的并发标记和并发清除过程中，垃圾收集线程，可以和用户线程一起并发工作，所以总体来看CMS收集器的没存回收是和用户线程一起并发执行的
 *  优点：并发收集停顿低       缺点：cpu压力大，标记清除会产生碎片
 *  必须要在堆内存用尽之前完成回收
 *  -------------------------------------------------------------------------------------------------------------------------------
 *  Serial Old: Serial 的老年代版本 单线程
 *  -XX:+UseSerialOldGC
 *  ================================================================================================================================
 *
 *  G1:横跨新生代养老代的收集器
 *      偏向于服务器的垃圾收集器
 *      有整理内存过程的垃圾收集器，不会产生内存碎片
 *      停顿时间上添加了预测机制，用户可以指定期望停顿时间
 *  -XX:+UseG1GC
 *
 *      划分成区块每一个块由1~32M不等
 *  java9以后成为了默认的垃圾收集器
 *
 *  优点
 *  1、充分利用了多cpu的优势
 *  2、整体上采用了标记整理算法，局部采用复制算法
 *  3、宏观上不在划分新生代和老年代，把内存划分成为了多个独立的子区域（region），可以近似地理解为一个棋盘
 *  4、在小范围内仍然划分新生代和老年代，保留了新生代和老年代，但是他们不再是物理隔离，
 *      而是一部分Region的集合且不需要Region是连续的，也就是说依然会采用不同的方式处理不同的区域
 *  5、G1虽然是分代收集器，但整个内存区域不存在物理上新生代和老年代的区别，也不需要完全独立的survivor堆做复制准备。
 *      G1只有逻辑上的分代概念，或者说每个分区都可能是随G1的运行在不同代之间前后切换
 *
 * 小区域范围的收集，形成连续的内存块
 * 四部
 * 初始标记：只标记GC Roots 能直接关联的对象
 * 并发标记：进行GC Roots Tracking的过程
 * 最终标记：修正并发标记期间，因程序运行标记发生变化的那一部分对象
 * 筛选回收：根据时间进行价值最大化的回收】
 * ；
 *
 *  对象的储存在逻辑上连续
 *
 *  新生区
 *  幸存区
 *  养老区
 *  大对象区
 *
 *  大对象物理连续存储
 *
 *  最大内存=2048个区域 * 32M      64G
 *
 *
 *
 *
 *
 *  =================================================================================================================================
 *  不同厂商不同版本的差别很大      这些垃圾回收器为HotSpot中的收集器
 *  新生代：Serial Copying     Parallel Scavenge      ParNew(Parallel New Gen)    G1
 *  老年代：Serial CMS(Serial Old)    Parallel Compacting(Parallel old)    CMS      G1
 *
 *  注：Serial Old 已经不推荐使用了
 *  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
public class GCDemo {
    public static void main(String[] args) {
        String a = "a";

        try{
            while (true){
                a += a + (new Random(1000000).nextInt());
            }
        }catch (Exception e){
            e.printStackTrace();
        }

    }
}
